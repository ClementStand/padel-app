import { supabase } from './supabase';

// --- Types ---
export interface Booking {
    id: string;
    clubId: string;
    clubName: string;
    date: string;
    time: string;
    status: 'pending' | 'confirmed' | 'rejected';
    userId: string;
    userName: string;
    participants?: { id: string, name: string }[];
}

export interface Club {
    id: string;
    name: string;
    courts: number;
}

export interface Player {
    id: string;
    name: string;
    elo: number;
    wins: number;
    matchesPlayed: number;
    country?: string;
    phone?: string;
    dob?: string;
    course?: string;
    year?: string;
    handedness?: 'right' | 'left';
    courtSide?: 'left' | 'right' | 'both';
    avatar?: string;
    password?: string;
}

export interface Match {
    id: string;
    date: string;
    team1Names: string;
    team2Names: string;
    score: string;
    winner: 1 | 2;
    eloChange: number;
}

// --- Fetching Data ---

export const getClubs = async (): Promise<Club[]> => {
    const { data, error } = await supabase.from('clubs').select('*');
    if (error) {
        console.error('Error loading clubs:', error);
        return [];
    }
    return data || [];
};

export const getBookings = async (): Promise<Booking[]> => {
    const { data, error } = await supabase
        .from('bookings')
        .select(`
            *,
            clubs ( name ),
            profiles ( full_name )
        `)
        .order('date', { ascending: false });

    if (error) return [];

    return data.map((b: any) => ({
        id: b.id,
        clubId: b.club_id,
        clubName: b.clubs?.name || 'Unknown Club',
        date: b.date,
        time: b.time,
        status: b.status,
        userId: b.user_id,
        userName: b.profiles?.full_name || 'Unknown User',
        participants: [{ id: b.user_id, name: b.profiles?.full_name || 'Unknown User' }]
    }));
};

export const getPlayers = async (): Promise<Player[]> => {
    const { data, error } = await supabase
        .from('profiles')
        .select('*')
        .order('elo', { ascending: false }); // Leaderboard order

    if (error) return [];

    return data.map((p: any) => ({
        id: p.id,
        name: p.full_name || 'Anonymous',
        elo: p.elo,
        wins: p.wins,
        matchesPlayed: p.matches_played
    }));
};

export const getMatches = async (): Promise<Match[]> => {
    const { data, error } = await supabase
        .from('matches')
        .select('*')
        .order('created_at', { ascending: false });

    if (error) return [];

    return data.map((m: any) => ({
        id: m.id,
        date: m.date,
        team1Names: m.team1_names,
        team2Names: m.team2_names,
        score: m.score,
        winner: m.winner,
        eloChange: m.elo_change
    }));
};

// --- Actions ---

export const createBooking = async (booking: {
    clubId: string;
    date: string;
    time: string;
    userId: string;
}) => {
    // 1. Check availability
    const { count } = await supabase
        .from('bookings')
        .select('*', { count: 'exact', head: true })
        .eq('club_id', booking.clubId)
        .eq('date', booking.date)
        .eq('time', booking.time)
        .neq('status', 'rejected');

    if (count !== null && count >= 6) {
        throw new Error("Full: This time slot is fully booked (Max 6 courts).");
    }

    // 2. Create booking
    const { data, error } = await supabase
        .from('bookings')
        .insert([
            {
                club_id: booking.clubId,
                user_id: booking.userId,
                date: booking.date,
                time: booking.time,
                status: 'pending'
            }
        ])
        .select();

    if (error) throw error;
    return data;
};

export const saveMatch = async (match: Match) => {
    // We need to map our Match object to the db columns if they differ, 
    // or just insert if they match.
    // Based on getMatches, the DB columns are snake_case.
    const { error } = await supabase
        .from('matches')
        .insert([
            {
                // id is usually auto-generated by DB, but if we generate it client side we can pass it. 
                // However, best practice is to let DB handle IDs or use UUIDs.
                // For now, let's omit ID if it's auto-generated, or pass if strictly needed.
                // The 'match' object from strict mode usually has 'id' as timestamp string, which might not match UUID.
                // Let's rely on DB generation for ID and ignore the client-side ID for creation.
                date: match.date,
                team1_names: match.team1Names,
                team2_names: match.team2Names,
                score: match.score,
                winner: match.winner,
                elo_change: match.eloChange
            }
        ]);

    if (error) {
        console.error('Error saving match:', error);
        throw error;
    }
};

export const updatePlayer = async (player: Player) => {
    // We update the profiles table
    const { error } = await supabase
        .from('profiles')
        .update({
            elo: player.elo,
            wins: player.wins,
            matches_played: player.matchesPlayed
        })
        .eq('id', player.id);

    if (error) {
        console.error('Error updating player:', error);
        throw error;
    }
};

export const deleteUser = async (userId: string) => {
    // For now, we'll just delete the profile. 
    // In a real app with Supabase Auth, you'd use the Admin API to delete the user account too.
    const { error } = await supabase
        .from('profiles')
        .delete()
        .eq('id', userId);

    if (error) {
        console.error('Error deleting user:', error);
        throw error;
    }
};

// --- AUTH ---
export const getCurrentUser = async (): Promise<Player | null> => {
    try {
        const { data: { user } } = await supabase.auth.getUser();
        if (!user) return null;

        // Fetch profile details
        const { data: profile, error } = await supabase
            .from('profiles')
            .select('*')
            .eq('id', user.id)
            .single();

        if (error || !profile) {
            console.error('Error fetching profile:', error);
            // Fallback for new users who might not have a profile yet? 
            // Or return basic info from auth
            return {
                id: user.id,
                name: user.user_metadata.full_name || 'Unknown',
                elo: 1200,
                wins: 0,
                matchesPlayed: 0
            };
        }

        return {
            id: profile.id,
            name: profile.full_name || 'Unknown',
            elo: profile.elo || 1200,
            wins: profile.wins || 0,
            matchesPlayed: profile.matches_played || 0,
            country: profile.country,
            course: profile.course,
            year: profile.year,
            dob: profile.dob,
            avatar: profile.avatar_url
        };
    } catch (e) {
        console.error("Error in getCurrentUser:", e);
        return null;
    }
};